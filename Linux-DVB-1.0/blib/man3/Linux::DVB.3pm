.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.35
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DVB 3"
.TH DVB 3 "2006-05-24" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Linux::DVB \- interface to (some parts of) the Linux DVB API
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Linux::DVB;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides an interface to the Linux \s-1DVB\s0 \s-1API\s0. It is a straightforward
translation of the C \s-1API\s0. You should read the Linux \s-1DVB\s0 \s-1API\s0 description to make
any sense of this module. It can be found here:
.PP
.Vb 1
\&   http://www.linuxtv.org/docs/dvbapi/dvbapi.html
.Ve
.PP
All constants from \fIfrontend.h\fR and \fIdemux.h\fR are exported by their C
name and by default.
.PP
Noteworthy differences to the C \s-1API:\s0 unions and sub-structs are usually
translated into flat perl hashes, i.e \f(CW\*(C`struct.u.qam.symbol_rate\*(C'\fR
becomes \f(CW\*(C`$struct\->{symbol_rate}\*(C'\fR.
.PP
Noteworthy limitations of this module include: No interface to the video,
audio and net devices. If you need this functionality bug the author.
.SH "Linux::DVB::Frontend CLASS"
.IX Header "Linux::DVB::Frontend CLASS"
.Sh "\s-1SYNOPSIS\s0"
.IX Subsection "SYNOPSIS"
.Vb 1
\& my $fe = new Linux::DVB::Frontend $path, $writable;
.Ve
.PP
.Vb 2
\& my $fe = new Linux::DVB::Frontend
\&             "/dev/dvb/adapter0/frontend0", 1;
.Ve
.PP
.Vb 3
\& $fe->fh; # filehandle
\& $fe->fd; # fileno
\& $fe->blocking (0); # or 1
.Ve
.PP
.Vb 3
\& $fe->{name}
\& $fe->{type}
\& $fe->frontend_info->{name}
.Ve
.PP
.Vb 2
\& $fe->status & FE_HAS_LOCK
\& print $fe->ber, $fe->snr, $fe->signal_strength, $fe->uncorrected;
.Ve
.PP
.Vb 3
\& my $tune = $fe->parameters;
\& $tune->{frequency};
\& $tune->{symbol_rate};
.Ve
.IP "$fe\->set (parameter => value, ...)" 4
.IX Item "$fe->set (parameter => value, ...)"
Sets frontend parameters. All values are stuffed into the
\&\f(CW\*(C`dvb_frontend_parameters\*(C'\fR structure without conversion and passed to
\&\s-1FE_SET_FRONTEND\s0.
.Sp
Returns true on success.
.Sp
All modes:
.Sp
.Vb 2
\&  frequency         =>
\&  inversion         =>
.Ve
.Sp
\&\s-1QPSK\s0 frontends:
.Sp
.Vb 2
\&  symbol_rate       =>
\&  fec_inner         =>
.Ve
.Sp
\&\s-1QAM\s0 frontends:
.Sp
.Vb 2
\&  symbol_rate       =>
\&  modulation        =>
.Ve
.Sp
\&\s-1QFDM\s0 frontends:
.Sp
.Vb 5
\&  bandwidth         =>
\&  code_rate_HP      =>
\&  code_rate_LP      =>
\&  constellation     =>
\&  transmission_mode =>
.Ve
.IP "$fe\->parameters" 4
.IX Item "$fe->parameters"
Calls \s-1FE_GET_FRONTEND\s0 and returns a hash reference that contains the same keys
as given to the \f(CW\*(C`set\*(C'\fR method.
.Sp
Example:
.Sp
.Vb 1
\&  Data::Dumper::Dumper $fe->get
.Ve
.Sp
.Vb 6
\&  {
\&    frequency   => 426000000, # 426 Mhz
\&    inversion   => 0,         # INVERSION_OFF
\&    symbol_rate => 6900000,   # 6.9 MB/s
\&    modulation  => 3,         # QAM_64
\&  }
.Ve
.ie n .IP "$ok = $fe\->diseqc_reset_overload" 4
.el .IP "$ok = \f(CW$fe\fR\->diseqc_reset_overload" 4
.IX Item "$ok = $fe->diseqc_reset_overload"
If the bus has been automatically powered off due to power overload, this
call restores the power to the bus. The call requires read/write access
to the device. This call has no effect if the device is manually powered
off. Not all \s-1DVB\s0 adapters support this call.
.ie n .IP "$ok = $fe\->diseqc_voltage (13|18)" 4
.el .IP "$ok = \f(CW$fe\fR\->diseqc_voltage (13|18)" 4
.IX Item "$ok = $fe->diseqc_voltage (13|18)"
Set the DiSEqC voltage to either 13 or 18 volts.
.ie n .IP "$ok = $fe\->diseqc_tone (1|0)" 4
.el .IP "$ok = \f(CW$fe\fR\->diseqc_tone (1|0)" 4
.IX Item "$ok = $fe->diseqc_tone (1|0)"
Enables (1) or disables (0) the DiSEqC continuous 22khz tone generation.
.ie n .IP "$ok = $fe\->diseqc_send_burst (0|1)" 4
.el .IP "$ok = \f(CW$fe\fR\->diseqc_send_burst (0|1)" 4
.IX Item "$ok = $fe->diseqc_send_burst (0|1)"
Sends a 22KHz tone burst of type \s-1SEC_MINI_A\s0 (0) or \s-1SEC_MINI_B\s0 (1).
.ie n .IP "$ok = $fe\->diseqc_cmd ($command)" 4
.el .IP "$ok = \f(CW$fe\fR\->diseqc_cmd ($command)" 4
.IX Item "$ok = $fe->diseqc_cmd ($command)"
Sends a DiSEqC command ($command is 3 to 6 bytes of binary data).
.ie n .IP "$reply = $fe\->diseqc_reply ($timeout)" 4
.el .IP "$reply = \f(CW$fe\fR\->diseqc_reply ($timeout)" 4
.IX Item "$reply = $fe->diseqc_reply ($timeout)"
Receives a reply to a DiSEqC 2.0 command and returns it as a binary octet
string 0..4 bytes in length (or \f(CW\*(C`undef\*(C'\fR in the error case).
.SH "Linux::DVB::Demux CLASS"
.IX Header "Linux::DVB::Demux CLASS"
.Sh "\s-1SYNOPSIS\s0"
.IX Subsection "SYNOPSIS"
.Vb 2
\& my $dmx = new Linux::DVB::Demux
\&             "/dev/dvb/adapter0/demux0";
.Ve
.PP
.Vb 3
\& $fe->fh; # filehandle
\& $fe->fd; # fileno
\& $fe->blocking (1); # non-blocking is default
.Ve
.PP
.Vb 5
\& $dmx->buffer (16384);
\& $dmx->sct_filter ($pid, "filter", "mask", $timeout=0, $flags=DMX_CHECK_CRC);
\& $dmx->pes_filter ($pid, $input, $output, $type, $flags=0);
\& $dmx->start; 
\& $dmx->stop;
.Ve
.SH "Linux::DVB::Decode CLASS"
.IX Header "Linux::DVB::Decode CLASS"
.Sh "\s-1SYNOPSIS\s0"
.IX Subsection "SYNOPSIS"
.Vb 1
\&   $si_decoded_hashref = Linux::DVB::Decode::si $section_data;
.Ve
.ie n .IP "$hashref = Linux::DVB::Decode::si $section_data" 4
.el .IP "$hashref = Linux::DVB::Decode::si \f(CW$section_data\fR" 4
.IX Item "$hashref = Linux::DVB::Decode::si $section_data"
Tries to parse the string inside \f(CW$section_data\fR as an \s-1SI\s0 table and
return it as a hash reference.  Only the first \s-1SI\s0 table will be returned
as hash reference, and the \f(CW$section_data\fR will be modified in-place by
removing the table data.
.Sp
The way to use this function is to append new data to your
\&\f(CW$section_data\fR and then call \f(CW\*(C`Linux::DVB::Decode::si\*(C'\fR in a loop until
it returns \f(CW\*(C`undef\*(C'\fR. Please ntoe, however, that the Linux \s-1DVB\s0 \s-1API\s0 will
return only one table at a time from sysread, so you can safely assume
that every sysread will return exactly one (or zero in case of errors) \s-1SI\s0
table.
.Sp
Here is an example of what to expect:
.Sp
.Vb 63
\&  {
\&    'segment_last_section_number' => 112,
\&    'table_id' => 81,
\&    'service_id' => 28129,
\&    'original_network_id' => 1,
\&    'section_syntax_indicator' => 1,
\&    'current_next_indicator' => 1,
\&    'events' => [
\&                  {
\&                    'running_status' => 0,
\&                    'start_time_hms' => 2097152,
\&                    'event_id' => 39505,
\&                    'free_CA_mode' => 0,
\&                    'start_time_mjd' => 53470,
\&                    'descriptors' => [
\&                                       {
\&                                         'event_name' => 'Nachrichten',
\&                                         'text' => '',
\&                                         'ISO_639_language_code' => 'deu',
\&                                         'type' => 77
\&                                       },
\&                                       {
\&                                         'programme_identification_label' => 337280,
\&                                         'type' => 105
\&                                       },
\&                                       {
\&                                         'raw_data' => '22:0010.04#00',
\&                                         'type' => 130
\&                                       }
\&                                     ],
\&                    'duration' => 1280
\&                  },
\&                  {
\&                    'running_status' => 0,
\&                    'start_time_hms' => 2098432,
\&                    'event_id' => 39506,
\&                    'free_CA_mode' => 0,
\&                    'start_time_mjd' => 53470,
\&                    'descriptors' => [
\&                                       {
\&                                         'event_name' => 'SR 1 - Nachtwerk',
\&                                         'text' => '',
\&                                         'ISO_639_language_code' => 'deu',
\&                                         'type' => 77
\&                                       },
\&                                       {
\&                                         'programme_identification_label' => 337285,
\&                                         'type' => 105
\&                                       },
\&                                       {
\&                                         'raw_data' => '22:0510.04#00',
\&                                         'type' => 130
\&                                       }
\&                                     ],
\&                    'duration' => 87296
\&                  }
\&                ],
\&    'last_table_id' => 81,
\&    'section_number' => 112,
\&    'last_section_number' => 176,
\&    'version_number' => 31,
\&    'transport_stream_id' => 1101
\&  }
.Ve
.ie n .IP "$text = Linux::DVB::Decode::text $data" 4
.el .IP "$text = Linux::DVB::Decode::text \f(CW$data\fR" 4
.IX Item "$text = Linux::DVB::Decode::text $data"
Converts text found in \s-1DVB\s0 si tables into perl text. Only iso\-8859\-1..\-11
and \s-1UTF\-16\s0 is supported, other encodings (big5 etc. is not. Bug me if you
need this).
.IP "%Linux::DVB::Decode::nibble_to_genre" 4
.IX Item "%Linux::DVB::Decode::nibble_to_genre"
A two-level hash mapping genre nibbles to genres, e.g.
.Sp
.Vb 2
\&   $Linux::DVB::Decode::nibble_to_genre{7}{6}
\&   => 'film/cinema'
.Ve
.ie n .IP "($sec,$min,$hour) = Linux::DVB::Decode::time $hms" 4
.el .IP "($sec,$min,$hour) = Linux::DVB::Decode::time \f(CW$hms\fR" 4
.IX Item "($sec,$min,$hour) = Linux::DVB::Decode::time $hms"
.PD 0
.ie n .IP "($mday,$mon,$year) = Linux::DVB::Decode::date $mjd" 4
.el .IP "($mday,$mon,$year) = Linux::DVB::Decode::date \f(CW$mjd\fR" 4
.IX Item "($mday,$mon,$year) = Linux::DVB::Decode::date $mjd"
.ie n .IP "($sec,$min,$hour,$mday,$mon,$year) = Linux::DVB::Decode::datetime $mjd\fR, \f(CW$hms" 4
.el .IP "($sec,$min,$hour,$mday,$mon,$year) = Linux::DVB::Decode::datetime \f(CW$mjd\fR, \f(CW$hms\fR" 4
.IX Item "($sec,$min,$hour,$mday,$mon,$year) = Linux::DVB::Decode::datetime $mjd, $hms"
.ie n .IP "$sec = Linux::DVB::Decode::time_linear $hms" 4
.el .IP "$sec = Linux::DVB::Decode::time_linear \f(CW$hms\fR" 4
.IX Item "$sec = Linux::DVB::Decode::time_linear $hms"
.ie n .IP "$sec = Linux::DVB::Decode::datetime_linear $mjd\fR, \f(CW$hms" 4
.el .IP "$sec = Linux::DVB::Decode::datetime_linear \f(CW$mjd\fR, \f(CW$hms\fR" 4
.IX Item "$sec = Linux::DVB::Decode::datetime_linear $mjd, $hms"
.PD
Break down a \*(L"\s-1DVB\s0 time\*(R" (modified julian date + bcd encoded seconds) into
it's components (non\-\f(CW\*(C`_linear\*(C'\fR) or into a seconds count (\f(CW\*(C`_linear\*(C'\fR
variants) since the epoch (\f(CW\*(C`datetime_linear\*(C'\fR) or the start of the day
(\f(CW\*(C`time_linear\*(C'\fR).
.Sp
The format of the returns value of the date and datetime functions is
\&\fInot\fR compatible with \f(CW\*(C`Time::Local\*(C'\fR. Use the \f(CW\*(C`_linear\*(C'\fR functions
instead.
.Sp
Example:
.Sp
.Vb 4
\&   my $time = Linux::DVB::Decode::datetime_linear $mjd, $hms
\&   printf "Starts at %s\en",
\&      POSIX::strftime "%Y-%m-%d %H:%M:%S",
\&         localtime $time;
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
.Vb 2
\& Marc Lehmann <schmorp@schmorp.de>, http://home.schmorp.de/
\& Magnus Schmidt, eMail at http://www.27b-6.de/email.php
.Ve
